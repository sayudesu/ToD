#include "SaveDataFunctions.h"
#include <DxLib.h>
#include <cassert>

#include <vector>

#include <string>
#include <fstream>
#include <sstream>
#include <iostream>

namespace
{
    // 外部ファイル読み込み用
    std::vector<int> m_loadData;
    // 
    GameData::Sound m_saveData;
    GameData::Sound m_soundBarData;
    // データ数カウント
    int dataNum = -1;
}

namespace SaveDataFunctions
{
    void Load()
    {
        // csvファイルを読み込んで数字の配列にしたい
        FILE* fp;

        if (fopen_s(&fp, "Data/Save/SaveData.csv", "rt") != 0)
        {
            // ファイルが存在しなかったら
            // 新しいcsvファイルを作成
            // デフォルトの値を記録
            GameData::Input data{};
            data.Bgm_ = 255;
            data.SE_ = 255;
            Save(data);
            // 新しく作ったファイルを開く
            // 開けない場合はリターン
            fp;
            if (fopen_s(&fp, "Data/Save/SaveData.csv", "rt"))return;
        }

        int chr;
        // 未確定
        int wNum = -1;
        // 横の要素数数える用
        int tempW = 0;

        int tempNum = 0;

        while (true)
        {        
            chr = fgetc(fp);    // 1文字読み込み
            // 区切り文字が見つかった
            if (chr == ',' ||
                chr == '\n' ||
                chr == EOF)
            {
                // dataTblにデータを入れる
                m_loadData.push_back(tempNum);
                dataNum++;
                tempNum = 0;

                // ファイルの終端に来たら終了
                if (chr == EOF)
                {
                    break;
                }
                else if (chr == ',')
                {
                    tempW++;    // 要素数数える
                }
                else   // chr == '\n'
                {
                    tempW++;    // 要素数数える
                    if (wNum < 0)
                    {
                        wNum = tempW;    // 要素数確定
                    }
                    /*else
                    {
                        assert(wNum == tempW);
                    }*/
                    tempW = 0;
                }
                // まだ終わってないので続けて読み込み
                continue;
            }

            // データは数字のみのはず
            assert(chr >= '0' && chr <= '9');

            // 数字なのは確定
            // 文字列を数値に変換したい
            // 268を読み込む
            // 1文字目は'2'    これを数値に変換していれる
            // 2文字目は'6'    tempNumは2 20 + 6  tempNum = 26
            // 3文字目は'8' tempNumは26 260+ 8 tempNum = 268
            tempNum = (tempNum * 10) + chr - '0';

            // データの区切りが見つかった時点でそこまでがデータのひとまとまり

        }
        // ファイルを閉じる
        fclose(fp);
    }

    void Save(GameData::Input data)
    {
        //FILEポインタの宣言
        FILE* fp1;
        // CSVファイルを開く
        fopen_s(&fp1, "Data/Save/SaveData.csv", "w");
        // CSVファイルに上書き保存
        fprintf(
            fp1,
            "%ld,%ld\n",
            data.Bgm_,
            data.SE_);
        // CSVファイルを閉じる
        fclose(fp1);

        // データを保管
        m_loadData[0] = data.Bgm_;
        m_loadData[1] = data.SE_;
    }

    // 0から255
    GameData::Sound GetSoundData()
    {
        m_saveData.Bgm = m_loadData[0];
        m_saveData.SE  = m_loadData[1];

        return m_saveData;
    }

    // 0から1000
    GameData::Sound GetSoundBarData()
    {   
        // 0から255を0から1000の割合に変換
        m_soundBarData.Bgm = (m_loadData[0] - 0) * (1000 - 0) / (255 - 0);
        m_soundBarData.SE = (m_loadData[1] - 0) * (1000 - 0) / (255 - 0);

        return m_soundBarData;
    }
}
